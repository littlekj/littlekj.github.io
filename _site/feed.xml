<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.5">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2024-03-16T16:22:15+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">清风拂33</title><subtitle>33的个人博客，公众号：233</subtitle><author><name>清风拂33</name></author><entry><title type="html">如何接住空投给 GitHub 用户的「泼天富贵」？</title><link href="http://localhost:4000/2024/03/04/how-to-receive-airdrop-to-github-users/" rel="alternate" type="text/html" title="如何接住空投给 GitHub 用户的「泼天富贵」？" /><published>2024-03-04T00:00:00+08:00</published><updated>2024-03-04T00:00:00+08:00</updated><id>http://localhost:4000/2024/03/04/how-to-receive-airdrop-to-github-users</id><content type="html" xml:base="http://localhost:4000/2024/03/04/how-to-receive-airdrop-to-github-users/"><![CDATA[<h2 id="背景">背景</h2>

<p>我的公众号里前几天发的一篇文章小火了一把，阅读量到了 5000+（看官您别笑，对于我这种没什么流量的号，这已经是顶流了）。</p>

<p>想着看看我的号里哪些内容最受欢迎，于是翻了一下历史群发文章的数据统计，阅读量最高的是这两篇：</p>

<ul>
  <li><a href="https://mp.weixin.qq.com/s/-nUGdRFGoE8K0W-buqhPVQ">GitHub 用户福利，符合条件可领取约 1500 元现金</a> <em>——2024/02/27</em></li>
  <li><a href="https://mp.weixin.qq.com/s/44v5uw4RnPSgsskgzYuTOg">GitHub 用户专属福利，实际到账 3K+，Namebase Airdrop</a> <em>——2020/02/21</em></li>
</ul>

<p>都是关于空投和钱的，而且最近也陆续有一些网友加我微信，咨询如何能获得类似空投的领取资格——和家人交流了一下，猜想可能是因为经济下行，大家关心的都是如何搞钱存钱。</p>

<p>我算是比较幸运的，这两次空投都有领取资格，在不需要额外付出什么成本的前提下，合计入账了 RMB 5000+，在如今挣点钱并不容易的大环境下，还是很香的。</p>

<p>我猜想后续这样的空投应该也还会出现。我就趁机在此，就大家普遍关心的话题，把我的理解小结一下，供大家参考。</p>

<h2 id="分析">分析</h2>

<p>首先看一下作为一名 GitHub 用户，这两次空投领取资格 <strong>门槛</strong> 分别是怎么样的。</p>

<p><strong>2024 年初的 Starknet 空投：</strong></p>

<ul>
  <li>
    <p>你在 2023-11-15 前，向整个 GitHub 上 star 数 top 5000 之一的项目至少贡献过 3 次 commit；</p>
  </li>
  <li>
    <p>至少有一次 commit 发生在 2018 年及以后。</p>
  </li>
</ul>

<p><strong>2020 年初的 Namebase 空投：</strong></p>

<ul>
  <li>
    <p>在 2019-02-04 这一天所在的那一周，你的 GitHub 账号有 15 个以上的 followers；</p>
  </li>
  <li>
    <p>保留有当时的 SSH / PGP 私钥。</p>
  </li>
</ul>

<p>从中我提取到的关键词是 <strong>贡献</strong> 和 <strong>影响力</strong>。</p>

<p>这些机构空投给 GitHub 用户，我估计一方面是回馈开发者，特别是参与构建与它们的项目相关的基础设施和技术项目的开发者，鼓励创新，另一方面也是借此扩大它们项目的影响力，吸引更多的人关注和参与进来。</p>

<h2 id="建议">建议</h2>

<p>虽然说不准未来的空投会采取什么样的角度来制定领取资格门槛，但我们从现在开始着手「埋伏笔」肯定是必要的。</p>

<p>接下来是对在 GitHub 活动的建议，其实就是三板斧——<strong>从 GitHub 学、在 GitHub 练、向 GitHub 作贡献</strong>。</p>

<p>一、从 GitHub 学：</p>

<ul>
  <li>Follow 你感兴趣的领域厉害的人物，持续关注他们在 GitHub 上的活动，学习他们的协作方式，了解他们关注的优秀项目和资料；</li>
  <li>找到与你工作和学习相关的有影响力的项目，挑选感兴趣的，进行深入学习；</li>
  <li>学习并掌握 GitHub 的工作流，学习版本控制、Issues、Pull Request 的规范；</li>
  <li>在需要寻找开源库或工具时，优先上 GitHub 搜索。</li>
</ul>

<p>二、在 GitHub 练：</p>

<ul>
  <li>将你自己的玩具项目源码大胆发上去，不断用你学习到的优秀的模式和架构对它们进行重构，形成你个人比较固定的流程和规范；</li>
  <li>使用 GitHub Pages 搭建自己的个人主页和博客，勤记录和分享笔记与心得。</li>
</ul>

<p>三、向 GitHub 作贡献：</p>

<ul>
  <li>创建你自己的实用项目，并长期维护——可以是代码，也可以是清单、文档、手册；</li>
  <li>在发现你使用的开源项目的问题或漏洞时，参考下面的流程去寻求帮助或协助解决，即使只是帮助修正了文档里的一处语法错误，这个世界也因你而变得更加完美了一点点：
  <img src="/images/posts/github/github-issues.png" alt="" /></li>
</ul>

<h2 id="小结">小结</h2>

<p>看到这里，可能有的朋友会问，「如果我都有这个能力和影响力了，还在乎空投这仨瓜俩枣？」</p>

<p>是的，你说得对，如果你依上面的建议提升了自己的能力，构建了自己的项目和影响力，给开源社区贡献了自己的力量，你所获得的有形和无形的收益可能远超自己的想象。</p>

<p>面对新的空投，你将有选择的自由。</p>]]></content><author><name>清风拂33</name></author><category term="GitHub" /><summary type="html"><![CDATA[不时的有数字货币基金会空投给 GitHub 用户，如何接住这天上掉的「馅饼」呢？]]></summary></entry><entry><title type="html">前端｜基于 Layui 实现动态搜索选择框</title><link href="http://localhost:4000/2024/03/01/layui-dynamic-search-select/" rel="alternate" type="text/html" title="前端｜基于 Layui 实现动态搜索选择框" /><published>2024-03-01T00:00:00+08:00</published><updated>2024-03-01T00:00:00+08:00</updated><id>http://localhost:4000/2024/03/01/layui-dynamic-search-select</id><content type="html" xml:base="http://localhost:4000/2024/03/01/layui-dynamic-search-select/"><![CDATA[<p>后端程序员的前端笔记，含金量，你懂的 :-P</p>

<h2 id="需求">需求</h2>

<p>网页端实现动态搜索选择框，要求：</p>

<ol>
  <li>下拉选项列表能根据用户输入内容动态刷新；</li>
  <li>最终提交的值必须是由选项列表中点选的；</li>
  <li>基于 Layui。</li>
</ol>

<h2 id="方案">方案</h2>

<p>一开始根据印象里常见的搜索选择框的样式，一直在探索如何基于 <code class="language-plaintext highlighter-rouge">&lt;select&gt;</code> 来实现。Layui 的搜索选择框并没有暴露监听输入内容的事件接口，在网上找到了两个思路，但实现得都不够完美。</p>

<p>一是参考 <a href="https://www.cnblogs.com/zqifa/p/layui-select-input-1.html">https://www.cnblogs.com/zqifa/p/layui-select-input-1.html</a>，在 <code class="language-plaintext highlighter-rouge">&lt;select&gt;</code> 上覆盖一个 <code class="language-plaintext highlighter-rouge">&lt;input&gt;</code>，监听 <code class="language-plaintext highlighter-rouge">&lt;input&gt;</code> 的输入内容然后触发模糊搜索，进而触发更新 <code class="language-plaintext highlighter-rouge">&lt;select&gt;</code> 的选项列表。可以基本达成需要的效果，有一个问题是选择列表展示后，必须选择一项才能关闭选项列表，而期望是点击空白区域选项列表自动关闭。</p>

<p>二是参考 <a href="https://gitee.com/layui/layui/issues/I6N5MZ">https://gitee.com/layui/layui/issues/I6N5MZ</a>，监听经过 Layui 渲染 <code class="language-plaintext highlighter-rouge">&lt;select&gt;</code> 后生成的 <code class="language-plaintext highlighter-rouge">&lt;input&gt;</code> 元素的事件，进而触发选项列表的刷新。这个方案的思路是挺好的，但是同样有一些小问题，比如下拉选项的展示/隐藏、输入焦点、输入内容保持等，都需要自己一一去干预。</p>

<p>这时在 Layui 的仓库找到 <a href="https://gitee.com/layui/layui/issues/I71WRL">这个 Issue</a>，贤心大大这样回应网友「能不能在选择框上加上可输入可下拉可搜索」的提问：</p>

<blockquote>
  <p>select 组件的定位就是只能赋值选项列表中的值，包括搜索，也只是从选项中匹配。若要支持自定义输入的值，可以借助 input + dropdown 组件来自定义实现哦。</p>
</blockquote>

<p>受此启发，我又思考了一下需求里的「搜索」：</p>

<ul>
  <li>我们的下拉选项列表完全由后端根据输入内容返回；</li>
  <li>Layui 的 select 搜索选择框的搜索，是根据输入内容匹配现有候选列表，纯前端行为；</li>
</ul>

<p>看了下 Layui 文档后发现 dropdown 有专门的 reloadData 的 API，经尝试后最终选择了基于 Layui 的 dropdown 组件来实现。</p>

<h2 id="实现">实现</h2>

<p>效果如下：</p>

<p><img src="/images/posts/frontend/fe-search-select.gif" alt="" /></p>

<p>示例代码如下：</p>

<ul>
  <li>其中 <code class="language-plaintext highlighter-rouge">mockData</code> 实现应按需替换成 ajax 请求，成功拿到数据之后再 <code class="language-plaintext highlighter-rouge">reloadData</code>；</li>
  <li>表单提交时需要使用 id 作为参数值，可以在 click 的时候给 input 添加自定义属性如 <code class="language-plaintext highlighter-rouge">data-id</code>，在输入监听事件里删除该属性值。</li>
</ul>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;!DOCTYPE html&gt;</span>
<span class="nt">&lt;html&gt;</span>
<span class="nt">&lt;head&gt;</span>
  <span class="nt">&lt;meta</span> <span class="na">charset=</span><span class="s">"utf-8"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;meta</span> <span class="na">name=</span><span class="s">"viewport"</span> <span class="na">content=</span><span class="s">"width=device-width, initial-scale=1"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;title&gt;</span>Demo<span class="nt">&lt;/title&gt;</span>
  <span class="nt">&lt;link</span> <span class="na">href=</span><span class="s">"https://unpkg.com/layui@2.9.6/dist/css/layui.css"</span> <span class="na">rel=</span><span class="s">"stylesheet"</span><span class="nt">&gt;</span>
<span class="nt">&lt;/head&gt;</span>
<span class="nt">&lt;body&gt;</span>
<span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">"layui-inline layui-padding-5"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;input</span> <span class="na">name=</span><span class="s">""</span> <span class="na">placeholder=</span><span class="s">"请搜索或选择"</span> <span class="na">class=</span><span class="s">"layui-input"</span> <span class="na">id=</span><span class="s">"ID-dropdown-demo"</span><span class="nt">&gt;</span>
<span class="nt">&lt;/div&gt;</span>
  
<span class="nt">&lt;script </span><span class="na">src=</span><span class="s">"https://unpkg.com/layui@2.9.6/dist/layui.js"</span><span class="nt">&gt;&lt;/script&gt;</span> 
<span class="nt">&lt;script&gt;</span>
<span class="nx">layui</span><span class="p">.</span><span class="nx">use</span><span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
  <span class="kd">var</span> <span class="nx">dropdown</span> <span class="o">=</span> <span class="nx">layui</span><span class="p">.</span><span class="nx">dropdown</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">$</span> <span class="o">=</span> <span class="nx">layui</span><span class="p">.</span><span class="nx">$</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">inst</span> <span class="o">=</span> <span class="nx">dropdown</span><span class="p">.</span><span class="nx">render</span><span class="p">({</span>
    <span class="na">elem</span><span class="p">:</span> <span class="dl">'</span><span class="s1">#ID-dropdown-demo</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">data</span><span class="p">:</span> <span class="p">[],</span>
    <span class="na">click</span><span class="p">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">obj</span><span class="p">){</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">elem</span><span class="p">.</span><span class="nx">val</span><span class="p">(</span><span class="nx">obj</span><span class="p">.</span><span class="nx">title</span><span class="p">);</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">elem</span><span class="p">.</span><span class="nx">attr</span><span class="p">(</span><span class="dl">'</span><span class="s1">data-id</span><span class="dl">'</span><span class="p">,</span> <span class="nx">obj</span><span class="p">.</span><span class="nx">id</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">});</span>

  <span class="nx">$</span><span class="p">(</span><span class="nx">inst</span><span class="p">.</span><span class="nx">config</span><span class="p">.</span><span class="nx">elem</span><span class="p">).</span><span class="nx">on</span><span class="p">(</span><span class="dl">'</span><span class="s1">input propertychange</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">elem</span> <span class="o">=</span> <span class="nx">$</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
    <span class="kd">var</span> <span class="nx">value</span> <span class="o">=</span> <span class="nx">elem</span><span class="p">.</span><span class="nx">val</span><span class="p">().</span><span class="nx">trim</span><span class="p">();</span>
    <span class="nx">elem</span><span class="p">.</span><span class="nx">removeAttr</span><span class="p">(</span><span class="dl">'</span><span class="s1">data-id</span><span class="dl">'</span><span class="p">);</span>

    <span class="kd">var</span> <span class="nx">dataNew</span> <span class="o">=</span> <span class="nx">mockData</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
    <span class="nx">dropdown</span><span class="p">.</span><span class="nx">reloadData</span><span class="p">(</span><span class="nx">inst</span><span class="p">.</span><span class="nx">config</span><span class="p">.</span><span class="nx">id</span><span class="p">,</span> <span class="p">{</span>
      <span class="na">data</span><span class="p">:</span> <span class="nx">dataNew</span>
    <span class="p">})</span>
  <span class="p">});</span>

  <span class="nx">$</span><span class="p">(</span><span class="nx">inst</span><span class="p">.</span><span class="nx">config</span><span class="p">.</span><span class="nx">elem</span><span class="p">).</span><span class="nx">on</span><span class="p">(</span><span class="dl">'</span><span class="s1">blur</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">elem</span> <span class="o">=</span> <span class="nx">$</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
    <span class="kd">var</span> <span class="nx">dataId</span> <span class="o">=</span> <span class="nx">elem</span><span class="p">.</span><span class="nx">attr</span><span class="p">(</span><span class="dl">'</span><span class="s1">data-id</span><span class="dl">'</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">dataId</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">elem</span><span class="p">.</span><span class="nx">val</span><span class="p">(</span><span class="dl">''</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">});</span>
  
  <span class="kd">function</span> <span class="nx">mockData</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[</span>
      <span class="p">{</span><span class="na">id</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="na">title</span><span class="p">:</span> <span class="nx">value</span> <span class="o">+</span> <span class="dl">'</span><span class="s1">1</span><span class="dl">'</span><span class="p">},</span>
      <span class="p">{</span><span class="na">id</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="na">title</span><span class="p">:</span> <span class="nx">value</span> <span class="o">+</span> <span class="dl">'</span><span class="s1">2</span><span class="dl">'</span><span class="p">}</span>
    <span class="p">];</span>
  <span class="p">}</span>
<span class="p">});</span>
<span class="nt">&lt;/script&gt;</span>
 
<span class="nt">&lt;/body&gt;</span>
<span class="nt">&lt;/html&gt;</span>
</code></pre></div></div>

<h2 id="小结">小结</h2>

<p>冷静地想清楚自己的需求和场景，有助于更快找到合适的组件和方案。</p>]]></content><author><name>清风拂33</name></author><category term="前端" /><summary type="html"><![CDATA[基于 Layui 实现动态搜索选择框。]]></summary></entry><entry><title type="html">GitHub 用户福利，符合条件可领取约 1500 元现金</title><link href="http://localhost:4000/2024/02/27/github-starknet-airdrop/" rel="alternate" type="text/html" title="GitHub 用户福利，符合条件可领取约 1500 元现金" /><published>2024-02-27T00:00:00+08:00</published><updated>2024-02-27T00:00:00+08:00</updated><id>http://localhost:4000/2024/02/27/github-starknet-airdrop</id><content type="html" xml:base="http://localhost:4000/2024/02/27/github-starknet-airdrop/"><![CDATA[<p>看到公众号沉默王二发的一篇文章 <a href="https://mp.weixin.qq.com/s/bnHpkDMzUyIFzmGk9r4ByA">《GitHub赚了211美刀后的感触》</a>，用自己的 GitHub 账号尝试了一下，1500 元现金到账，有兴趣的朋友们可以一试。</p>

<h2 id="省流">省流</h2>

<p>Starknet 基金会启动了第一轮 Starknet 供应计划，将向近 130 万个地址分发超过 7 亿个 Starknet 代币（STRK），其中有 2.1% 分发给开源开发者。STRK 可以理解为一种数字货币，领取到后可以通过交易转换成现金。</p>

<p>可以通过 <a href="https://provisions.starknet.io">https://provisions.starknet.io</a> 网站查询是否有资格领取 STRK。</p>

<blockquote>
  <p>Update 2024/02/29 ref <a href="https://www.guozaoke.com/t/107113#reply7">https://www.guozaoke.com/t/107113#reply7</a></p>

  <p>符合条件的 GitHub 用户可以在下面两个文件之一搜到自己的 ID：</p>

  <ul>
    <li><a href="https://raw.githubusercontent.com/starknet-io/provisions-data/main/github/github-0.json">https://raw.githubusercontent.com/starknet-io/provisions-data/main/github/github-0.json</a></li>
    <li><a href="https://raw.githubusercontent.com/starknet-io/provisions-data/main/github/github-1.json">https://raw.githubusercontent.com/starknet-io/provisions-data/main/github/github-1.json</a></li>
  </ul>
</blockquote>

<p>如果发现有资格，可以继续阅读；如果没有资格，就不用浪费时间继续看了。另外，可以推荐给你在 GitHub 活跃的朋友试试。</p>

<h2 id="领取资格查询">领取资格查询</h2>

<ol>
  <li>
    <p>打开 <a href="https://provisions.starknet.io/">https://provisions.starknet.io/</a> 网站；</p>
  </li>
  <li>
    <p>往下翻，找到 Eligibility check only 链接，点击打开：</p>

    <p><img src="/images/posts/github/eligibility-check.png" alt="eligibility check" /></p>
  </li>
  <li>
    <p>切换到 GitHub，输入 GitHub 用户名，点击 Go：</p>

    <p><img src="/images/posts/github/github-go.png" alt="github-go" /></p>
  </li>
  <li>
    <p>如果有资格，会看到如下界面：</p>

    <p><img src="/images/posts/github/has-eligibility.png" alt="has-eligibility" /></p>

    <p>点 See your allocation，会看到能领取的 STRK 数量：</p>

    <p><img src="/images/posts/github/strk-count.png" alt="strk-count" /></p>
  </li>
</ol>

<h2 id="领取-strk">领取 STRK</h2>

<ol>
  <li>
    <p>在上面领取资格查询的最后一步点击 Disconnect，会回到第 2 步界面，点击 Claim STRK；</p>
  </li>
  <li>
    <p>勾选，Confirm：</p>

    <p><img src="/images/posts/github/terms-of-use-confirm.png" alt="" /></p>
  </li>
  <li>
    <p>选择钱包，我这里用的 Argent X，根据提示下载安装浏览器插件，生成一个钱包地址：</p>

    <p><img src="/images/posts/github/argent-x.png" alt="" /></p>
  </li>
  <li>
    <p>选择 GitHub，Sign in：</p>

    <p><img src="/images/posts/github/github-sign-in.png" alt="" /></p>
  </li>
  <li>
    <p>按提示操作，看到如下界面就是领取成功了：</p>

    <p><img src="/images/posts/github/token-claimed.png" alt="" /></p>
  </li>
</ol>

<h2 id="转换成现金">转换成现金</h2>

<ol>
  <li>
    <p>注册一个数字货币交易所账户，建议选择头部交易所，如币安、欧易，我使用的是 <a href="https://www.okx.com/cn/">欧易（OKX）</a>；</p>
  </li>
  <li>
    <p>在 OKX 的资金账户里 充币-选择 STRK-生成充币地址，选择将资金充入交易账户，复制充币地址：</p>

    <p><img src="/images/posts/github/balance-recharge.png" alt="" /></p>

    <p><img src="/images/posts/github/recharge-address.png" alt="" /></p>
  </li>
  <li>
    <p>打开之前安装的 Argent X 钱包浏览器插件，点击 Send，输入充币地址，填入 STRK 数量（可以点击 Max 选择最大转出数量），点击 Review send：</p>

    <p><img src="/images/posts/github/argent-x-send.png" alt="" /></p>
  </li>
  <li>
    <p>稍等一小会，刷新 OKX 应该就能看到 STRK 充进来了，在交易菜单里找到 币币，搜索 STRK/USDT，点击后输入数量，市价卖出：</p>

    <p><img src="/images/posts/github/strk-to-usdt.png" alt="" /></p>
  </li>
  <li>
    <p>资金划转，将 USDT 从 交易账户 转到 资金账户；</p>
  </li>
  <li>
    <p>买币-快捷买币-出售，USDT to CNY，全部出售，支付宝收款，支付宝到账后确认并放币即可，我最终到账 1533.8 元人民币。</p>

    <p><img src="/images/posts/github/take-in.png" alt="" /></p>
  </li>
</ol>

<h2 id="小结">小结</h2>

<p>天上不会掉馅饼，但是定向投放的合法福利，我们要接住！</p>

<p>类似的空投，2020 年初也经历过一次，当时也有记录：<a href="https://mp.weixin.qq.com/s/44v5uw4RnPSgsskgzYuTOg">GitHub 用户专属福利，实际到账 3K+，Namebase Airdrop</a>，当时是将 HNS 转换到 BTC 然后提现的，本次操作时看了下，BTC 的价格相对当时翻了约五倍，所以……将数字货币留着不提现，等增值也是一种思路。</p>

<p>在 Starknet 的网站上，有提到空投给 GitHub 用户的原因：</p>

<blockquote>
  <p>In addition, STRK will be distributed to those who helped to develop the larger ecosystem of open-source software and infrastructure, as their work has become a public good and contributed to the emergence of a more open and inclusive web.</p>
</blockquote>

<p>所以如果你符合领取资格，你必然也曾为构建有影响力的开源软件和基础设施贡献过力量，这是你应得的！</p>

<h2 id="参考链接">参考链接</h2>

<ul>
  <li><a href="https://www.starknet.io/en/content/starknet-provisions-program">https://www.starknet.io/en/content/starknet-provisions-program</a></li>
  <li><a href="https://provisions.starknet.io">https://provisions.starknet.io</a></li>
  <li><a href="https://zhuanlan.zhihu.com/p/683415610">https://zhuanlan.zhihu.com/p/683415610</a></li>
  <li><a href="https://mp.weixin.qq.com/s/bnHpkDMzUyIFzmGk9r4ByA">https://mp.weixin.qq.com/s/bnHpkDMzUyIFzmGk9r4ByA</a></li>
</ul>]]></content><author><name>清风拂33</name></author><category term="GitHub" /><summary type="html"><![CDATA[Starknet 供应计划，符合条件的 GitHub 用户可领取约 1500 元。]]></summary></entry><entry><title type="html">DIY｜ikbc C87 机械键盘有线改蓝牙小结</title><link href="http://localhost:4000/2024/02/05/ikbc-c87-single-mode-to-three-mode/" rel="alternate" type="text/html" title="DIY｜ikbc C87 机械键盘有线改蓝牙小结" /><published>2024-02-05T00:00:00+08:00</published><updated>2024-02-05T00:00:00+08:00</updated><id>http://localhost:4000/2024/02/05/ikbc-c87-single-mode-to-three-mode</id><content type="html" xml:base="http://localhost:4000/2024/02/05/ikbc-c87-single-mode-to-three-mode/"><![CDATA[<p>前一阵把家里的 Filco 圣手二代机械键盘单模改三模后，体验挺不错，想着改装的工具买了只用一回也比较浪费，顺手把放公司用的 ikbc C87 也改了吧。</p>

<p>本次仍然使用与之前相同的方案，具体方案及操作过程可以参考 <a href="{post_url 2023-11-26-filco-keyboard-single-mode-to-three-mode}">DIY｜Filco 圣手二代机械键盘单模改三模</a>，以及里面列举的参考链接，在此不展开，重点小结一下改装过程及使用过程中的一些新的体会。</p>

<p>改装过程因为有了改装上一把的经验，本次更加熟练和顺利，但也得到了两点新经验：</p>

<ol>
  <li>为了开拓底板上安装模块和电池的空间，一般会干掉一些栅格，使用美工刀+尖嘴钳能很轻松完成；</li>
  <li>钻孔的时候，把底板和上盖扣在一起后再钻，可以避免孔位没对齐的尴尬。</li>
</ol>

<p>施工图：</p>

<p><img src="/images/posts/diy/ikbc-c87-inner.jpg" alt="ikbc C87 内部" /></p>

<p>改装完到现在也使用了一个多月了，结合我自己的体验以及网友在上一篇文章的留言，有个痛点是续航。</p>

<p>续航应该是取决于电池容量、使用强度、键盘本身和改装模块的耗电情况等，与厂家量产的原生三模还是有非常明显的差距的。比如我手上的两把：</p>

<ul>
  <li>Filco 圣手二代 87 键，塞进 5000mAh 电池，放在家低频度使用，充一次电用两个月应该没问题；</li>
  <li>ikbc C87，使用 3000mAh 电池，放在公司高强度使用，充一次电只能使用一星期左右。</li>
</ul>

<p>有点电量焦虑。</p>

<p>所以，现在如果有人问我要不要把手上的键盘自己有线改无线，我的建议是，如果能找到手感合适价钱合适的，直接买一把新的吧 :-P</p>]]></content><author><name>清风拂33</name></author><category term="DIY" /><summary type="html"><![CDATA[ikbc C87 机械键盘单模改三模]]></summary></entry><entry><title type="html">Java｜SpringBoot 项目开发时，让 FreeMarker 文件编辑后自动更新</title><link href="http://localhost:4000/2023/12/11/idea-freemarker-hot-reload/" rel="alternate" type="text/html" title="Java｜SpringBoot 项目开发时，让 FreeMarker 文件编辑后自动更新" /><published>2023-12-11T00:00:00+08:00</published><updated>2023-12-11T00:00:00+08:00</updated><id>http://localhost:4000/2023/12/11/idea-freemarker-hot-reload</id><content type="html" xml:base="http://localhost:4000/2023/12/11/idea-freemarker-hot-reload/"><![CDATA[<p>正在维护的一个 SpringBoot 项目是前后端一体的，页面使用 FreeMarker 编写。在开发过程中，ftl 文件编辑后，每次都需要重启应用才能看到效果，效率非常低下。这里记录通过哪些配置后，可以让它们免重启自动更新。</p>

<ol>
  <li>
    <p>在应用的 pom.xml 文件里，做如下修改：</p>

    <div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="nt">&lt;dependencies&gt;</span>
     <span class="c">&lt;!-- 添加以下依赖 --&gt;</span>
     <span class="nt">&lt;dependency&gt;</span>
         <span class="nt">&lt;groupId&gt;</span>org.springframework.boot<span class="nt">&lt;/groupId&gt;</span>
         <span class="nt">&lt;artifactId&gt;</span>spring-boot-devtools<span class="nt">&lt;/artifactId&gt;</span>
         <span class="nt">&lt;optional&gt;</span>true<span class="nt">&lt;/optional&gt;</span>
         <span class="nt">&lt;scope&gt;</span>runtime<span class="nt">&lt;/scope&gt;</span>
     <span class="nt">&lt;/dependency&gt;</span>
 <span class="nt">&lt;/dependencies&gt;</span>

 <span class="nt">&lt;build&gt;</span>
     <span class="nt">&lt;finalName&gt;</span>${artifactId}<span class="nt">&lt;/finalName&gt;</span>
     <span class="nt">&lt;plugins&gt;</span>
         <span class="nt">&lt;plugin&gt;</span>
             <span class="nt">&lt;groupId&gt;</span>org.springframework.boot<span class="nt">&lt;/groupId&gt;</span>
             <span class="nt">&lt;artifactId&gt;</span>spring-boot-maven-plugin<span class="nt">&lt;/artifactId&gt;</span>
             <span class="nt">&lt;configuration&gt;</span>
                 <span class="c">&lt;!-- 添加以下这一行 --&gt;</span>
                 <span class="nt">&lt;fork&gt;</span>true<span class="nt">&lt;/fork&gt;</span>
             <span class="nt">&lt;/configuration&gt;</span>
         <span class="nt">&lt;/plugin&gt;</span>
     <span class="nt">&lt;/plugins&gt;</span>
 <span class="nt">&lt;/build&gt;</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>在 application-dev.properties 文件里添加如下内容：</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> # freemarker hot reload
 spring.freemarker.cache=false
 spring.freemarker.settings.template_update_delay=0
</code></pre></div>    </div>

    <p>禁用 FreeMarker 缓存，有更改后即时更新。</p>
  </li>
  <li>
    <p>修改 IDEA 配置，开启自动编译：</p>

    <p><img src="/images/posts/java/idea-build-project-automatically.png" alt="" /></p>
  </li>
  <li>
    <p>编译应用运行时的 Run/Debug Configurations：</p>

    <p><img src="/images/posts/java/idea-run-debug-configurations.png" alt="" /></p>

    <p>将 On ‘Update’ action: Update classes and resources 和 On frame deactivation: Update classes and resources 配置打开。</p>
  </li>
</ol>

<p>关于 spring-boot-devtools 的相关用途与说明，可以参考 Spring 官方文档：<a href="https://docs.spring.io/spring-boot/docs/2.7.18/reference/html/using.html#using.devtools">https://docs.spring.io/spring-boot/docs/2.7.18/reference/html/using.html#using.devtools</a>，可以看到，如果想要在开发过程中修改 Java 代码后免于手动重启，也可以借助于 spring-boot-devtools 的相关配置。</p>

<p>参考链接：</p>

<ul>
  <li><a href="https://docs.spring.io/spring-boot/docs/2.7.18/reference/html/using.html#using.devtools">https://docs.spring.io/spring-boot/docs/2.7.18/reference/html/using.html#using.devtools</a></li>
  <li><a href="https://blog.csdn.net/silentwolfyh/article/details/85048745">https://blog.csdn.net/silentwolfyh/article/details/85048745</a></li>
  <li><a href="https://www.cnblogs.com/ios9/p/14410299.html">https://www.cnblogs.com/ios9/p/14410299.html</a></li>
</ul>]]></content><author><name>清风拂33</name></author><category term="Java" /><summary type="html"><![CDATA[FreeMarker 文件编辑后，如果每次都需要重启才能看到效果，那效率会非常低下。通过一些配置可以让它们自动更新。]]></summary></entry><entry><title type="html">iOS｜获取 Distribution Managed 证书的 SHA-1 指纹和公钥</title><link href="http://localhost:4000/2023/12/09/ios-get-distribution-managed-certificates-finger-print-and-public-key/" rel="alternate" type="text/html" title="iOS｜获取 Distribution Managed 证书的 SHA-1 指纹和公钥" /><published>2023-12-09T00:00:00+08:00</published><updated>2023-12-09T00:00:00+08:00</updated><id>http://localhost:4000/2023/12/09/ios-get-distribution-managed-certificates-finger-print-and-public-key</id><content type="html" xml:base="http://localhost:4000/2023/12/09/ios-get-distribution-managed-certificates-finger-print-and-public-key/"><![CDATA[<p>最近在处理 APP 备案的事情，其中 iOS 平台的资料里要求填写签名证书的 SHA-1 指纹和公钥。</p>

<p>按照阿里云的操作指南 <a href="https://help.aliyun.com/zh/icp-filing/fill-in-app-feature-information">https://help.aliyun.com/zh/icp-filing/fill-in-app-feature-information</a> 进行操作时，在公钥与签名 SHA1 值获取这一步遇到了问题：我们证书的类型与指南中显示的不同，是 Distribution Managed 类型的，苹果开发者网站上不提供下载，自然也就无法直接拿到公钥和 SHA-1 指纹了。</p>

<p>到了这个时间点，这类问题我当然不会是第一个遇到和解决的，经过一番搜索，找到了可行的参考方法：<a href="https://blog.csdn.net/weixin_50340188/article/details/133023592">https://blog.csdn.net/weixin_50340188/article/details/133023592</a>，这里将完整的操作步骤也做个记录。</p>

<ol>
  <li>访问 <a href="https://developer.apple.com/cn/">https://developer.apple.com/cn/</a>，使用 App 对应的 iOS 开发者账号登录；</li>
  <li>在计划资源中点击证书进入证书列表页面：
 <img src="/images/posts/ios/view-certificates.png" alt="" /></li>
  <li>在证书列表页面 F12 打开浏览器开发者工具，刷新页面，在网络标签中找到 certificates 这次请求，在响应内容的 data 数组里找到需要的那个证书的 attribites.certificateContent 字段，如图所求；
 <img src="/images/posts/ios/ios-certificate-content-field.png" alt="" /></li>
  <li>将 attributes.certificateContent 字段的完整内容复制保存到一个新的文本文件中，并将该文本文件后缀名改为 .cer，如 test.cer；</li>
  <li>将 test.cer 文件传送到一台 <strong>Windows 电脑</strong>，双击打开，切到详细信息标签，分别点击上面的公钥、指纹，下方显示的字段值就是我们需要的，用 Ctrl-A、Ctrl-C、Ctrl-V 将它们复制出来即可。
 <img src="/images/posts/ios/public-key.jpeg" alt="" />
 <img src="/images/posts/ios/finger-print.jpeg" alt="" /></li>
</ol>

<p>实测可行，已顺利通过审核。</p>

<h2 id="参考">参考</h2>

<ul>
  <li><a href="https://help.aliyun.com/zh/icp-filing/fill-in-app-feature-information">https://help.aliyun.com/zh/icp-filing/fill-in-app-feature-information</a></li>
  <li><a href="https://blog.csdn.net/weixin_50340188/article/details/133023592">https://blog.csdn.net/weixin_50340188/article/details/133023592</a></li>
</ul>]]></content><author><name>清风拂33</name></author><category term="iOS" /><summary type="html"><![CDATA[获取 Distribution Managed 证书的公钥和 SHA-1 指纹。]]></summary></entry><entry><title type="html">DIY｜Filco 圣手二代机械键盘单模改三模</title><link href="http://localhost:4000/2023/11/26/filco-keyboard-single-mode-to-three-mode/" rel="alternate" type="text/html" title="DIY｜Filco 圣手二代机械键盘单模改三模" /><published>2023-11-26T00:00:00+08:00</published><updated>2023-11-26T00:00:00+08:00</updated><id>http://localhost:4000/2023/11/26/filco-keyboard-single-mode-to-three-mode</id><content type="html" xml:base="http://localhost:4000/2023/11/26/filco-keyboard-single-mode-to-three-mode/"><![CDATA[<p>前一阵觉得家里的书桌比较零乱，特别是有时候需要切换家用与工作笔记本电脑时，需要拔插的线也偏多，于是就想着将键盘由有线换成无线，既可以减少一根线，又可以在切换电脑时少一步拔插，方便一些。</p>

<p>我现在的键盘是一把有线单模的 Filco 圣手二代 87 键青轴，乃数年前离开帝都时好友所赠，一直用到现在，手感与品质都很好，虽说现在各种国产品牌和轴体的机械键盘层出不穷，价钱不贵评价也不错，但我还真舍不得换。所以对我来说最好的选择就是将其改成蓝牙无线键盘。</p>

<p>纪念下它原本的样子：</p>

<p><img src="/images/posts/diy/filco-keyboard-init.jpg" alt="" /></p>

<p>上网搜索了一下，发现有卖家出售通用的有线键盘改有线/蓝牙/无线三模的模块，按卖家的建议先拆开键盘，确定了里面有足够的改造空间后，下单购买了模块和电池。</p>

<p>拆得七零八落：</p>

<p><img src="/images/posts/diy/filco-keyboard-split.jpg" alt="" /></p>

<p>模块到了以后，改装过程主要参考了下面的两个视频，比较简单，在此不赘述：</p>

<ul>
  <li>有线键盘改无线3模键盘视频：<a href="https://www.bilibili.com/video/BV1au4y1k7bq/">https://www.bilibili.com/video/BV1au4y1k7bq/</a></li>
  <li>Filco 圣手二代有线改装蓝牙，加装猫爪：<a href="https://www.bilibili.com/video/BV1PN411Z7Ms/">https://www.bilibili.com/video/BV1PN411Z7Ms/</a></li>
</ul>

<p>用到的工具：</p>

<ul>
  <li>拆解：十字螺丝刀，塑料撬片</li>
  <li>改装：美工刀，热熔胶枪，吹风机，手电钻，绝缘热缩管、打火机</li>
</ul>

<p>加装内部模块后：</p>

<p><img src="/images/posts/diy/filco-keyboard-inner.jpg" alt="" /></p>

<p>装配完成以后——桌面也更加简洁清爽了：</p>

<p><img src="/images/posts/diy/filco-keyboard-final.jpg" alt="" /></p>

<p>先后拆坏过手表、电脑的手残党在操作过程中总结的心得：</p>

<ol>
  <li>有称手的工具可以事半功倍；</li>
  <li>如果想弄得完美一点，就多花一点耐心和细心；</li>
  <li>量空间时，多留一点余量，不要太刚好，胶也会占高度。</li>
</ol>

<p>整个改装的原料、工具，加上花费的时间，成本也可以购买一把不错的新键盘了，但意义不可同日而语，既保留了原来的手感和纪念意义，又增加了无线的便利性，还是很值得的。</p>]]></content><author><name>清风拂33</name></author><category term="DIY" /><summary type="html"><![CDATA[Filco 圣手二代 87 键机械键盘单模改三模。]]></summary></entry><entry><title type="html">Android｜集成 slf4j + logback 作为日志框架</title><link href="http://localhost:4000/2023/10/26/android-app-integrate-logback/" rel="alternate" type="text/html" title="Android｜集成 slf4j + logback 作为日志框架" /><published>2023-10-26T00:00:00+08:00</published><updated>2023-10-26T00:00:00+08:00</updated><id>http://localhost:4000/2023/10/26/android-app-integrate-logback</id><content type="html" xml:base="http://localhost:4000/2023/10/26/android-app-integrate-logback/"><![CDATA[<p>最近在做一个 Android APP 的日志改造时，想要满足如下需求：</p>

<ol>
  <li>
    <p>能够很方便地使用可变参数的方式输出日志；</p>
  </li>
  <li>
    <p>日志能够根据级别输出到控制台和文件；</p>
  </li>
  <li>
    <p>能够按照日期和文件大小进行日志文件的切割，滚动保存指定天数的日志，自动清理旧日志。</p>
  </li>
</ol>

<p>基于这个需求，我搜了一下「Android 日志框架」，大多网友推荐的是 logger、timber、xLog 等等，看着也不错。不过出于几年后端开发的经验和习惯，我进一步了解，发现熟悉的 log4j 和 logback 在 Android 上也有人做过适配，所以最终决定使用 slf4j + logback，以在前后端开发中取得一致的体验。</p>

<p>做过 Java 后端开发的同学，对于 slf4j + logback 的组合一般不陌生，而 Android 开发的同学则可能不一定听过它们。所以，本文将从零开始，记录如何在 Android APP 中集成 slf4j + logback 作为日志框架，并使用 Lombok 注解生成日志对象。</p>

<h2 id="集成-slf4j--logback">集成 slf4j + logback</h2>

<p>logback-android 项目地址：<a href="https://github.com/tony19/logback-android">https://github.com/tony19/logback-android</a></p>

<p>一、在项目/模块的 build.gradle 文件中添加依赖：</p>

<div class="language-groovy highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">dependencies</span> <span class="o">{</span>
  <span class="n">implementation</span> <span class="s1">'org.slf4j:slf4j-api:2.0.7'</span>
  <span class="n">implementation</span> <span class="s1">'com.github.tony19:logback-android:3.0.0'</span>
<span class="o">}</span>
</code></pre></div></div>

<p>如果是单模块项目，可以直接在 app/build.gradle 文件中添加，如果是多模块项目，可以在一个公共模块的 build.gradle 文件中添加，记得将 slf4j-api 的 <code class="language-plaintext highlighter-rouge">implementation</code> 改为 <code class="language-plaintext highlighter-rouge">api</code> 才可被其它模块引用。</p>

<p>二、创建日志配置文件 <code class="language-plaintext highlighter-rouge">app/src/main/assets/logback.xml</code>：</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;configuration</span> <span class="na">debug=</span><span class="s">"false"</span>
    <span class="na">xmlns=</span><span class="s">"https://tony19.github.io/logback-android/xml"</span>
    <span class="na">xmlns:xsi=</span><span class="s">"http://www.w3.org/2001/XMLSchema-instance"</span>
    <span class="na">xsi:schemaLocation=</span><span class="s">"https://tony19.github.io/logback-android/xml https://cdn.jsdelivr.net/gh/tony19/logback-android/logback.xsd"</span>
<span class="nt">&gt;</span>

    <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"LOG_DIR"</span> <span class="na">value=</span><span class="s">"${EXT_DIR:-${DATA_DIR}}/test/log"</span><span class="nt">/&gt;</span>
    
    <span class="nt">&lt;appender</span> <span class="na">name=</span><span class="s">"logcat"</span> <span class="na">class=</span><span class="s">"ch.qos.logback.classic.android.LogcatAppender"</span><span class="nt">&gt;</span>
        <span class="nt">&lt;tagEncoder&gt;</span>
            <span class="nt">&lt;pattern&gt;</span>%logger{12}<span class="nt">&lt;/pattern&gt;</span>
        <span class="nt">&lt;/tagEncoder&gt;</span>
        <span class="nt">&lt;encoder&gt;</span>
            <span class="nt">&lt;pattern&gt;</span>[%-20thread] %msg<span class="nt">&lt;/pattern&gt;</span>
        <span class="nt">&lt;/encoder&gt;</span>
    <span class="nt">&lt;/appender&gt;</span>

    <span class="nt">&lt;appender</span> <span class="na">name=</span><span class="s">"local_file"</span> <span class="na">class=</span><span class="s">"ch.qos.logback.core.rolling.RollingFileAppender"</span><span class="nt">&gt;</span>
        <span class="nt">&lt;file&gt;</span>${LOG_DIR}/test.log<span class="nt">&lt;/file&gt;</span>
        <span class="nt">&lt;encoder&gt;</span>
            <span class="nt">&lt;pattern&gt;</span>%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n<span class="nt">&lt;/pattern&gt;</span>
        <span class="nt">&lt;/encoder&gt;</span>
        <span class="nt">&lt;rollingPolicy</span> <span class="na">class=</span><span class="s">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span><span class="nt">&gt;</span>
            <span class="nt">&lt;fileNamePattern&gt;</span>${LOG_DIR}/test.%d.log<span class="nt">&lt;/fileNamePattern&gt;</span>
            <span class="nt">&lt;maxHistory&gt;</span>15<span class="nt">&lt;/maxHistory&gt;</span>
        <span class="nt">&lt;/rollingPolicy&gt;</span>
    <span class="nt">&lt;/appender&gt;</span>

    <span class="nt">&lt;root</span> <span class="na">level=</span><span class="s">"DEBUG"</span><span class="nt">&gt;</span>
        <span class="nt">&lt;appender-ref</span> <span class="na">ref=</span><span class="s">"logcat"</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;/root&gt;</span>

    <span class="nt">&lt;root</span> <span class="na">level=</span><span class="s">"INFO"</span><span class="nt">&gt;</span>
        <span class="nt">&lt;appender-ref</span> <span class="na">ref=</span><span class="s">"local_file"</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;/root&gt;</span>
<span class="nt">&lt;/configuration&gt;</span>
</code></pre></div></div>

<p>以上配置表示 DEBUG 及以上级别的日志输出到控制台，INFO 及以上级别的日志输出到文件，文件按照日期切割，最多保留 15 天的日志。</p>

<p>大家可以按需配置，比如还可以限定单个文件大小、自定义日志输出的格式等等。</p>

<p>在项目的 Wiki 里提到有一点是 Android 开发者比较关注的，就是日志有保存路径，既可以指定绝对路径，也可以用变量，比如：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">${DATA_DIR}</code> 表示 <code class="language-plaintext highlighter-rouge">Context.getFilesDir()</code>；</li>
  <li><code class="language-plaintext highlighter-rouge">${EXT_DIR}</code> 表示 <code class="language-plaintext highlighter-rouge">Context.getExternalFilesDir(null)</code>；</li>
  <li><code class="language-plaintext highlighter-rouge">${EXT_DIR:-${DATA_DIR}}</code> 表示当 <code class="language-plaintext highlighter-rouge">EXT_DIR</code> 可用时使用 <code class="language-plaintext highlighter-rouge">EXT_DIR</code>，否则使用 <code class="language-plaintext highlighter-rouge">DATA_DIR</code>；</li>
  <li><code class="language-plaintext highlighter-rouge">${PACKAGE_NAME}</code> 表示包名；</li>
  <li><code class="language-plaintext highlighter-rouge">${VERSION_NAME}</code> 表示版本名；</li>
  <li><code class="language-plaintext highlighter-rouge">${VERSION_CODE}</code> 表示版本号。</li>
</ul>

<p>三、可以开始使用 slf4j 的 API 进行日志打印了：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">org.slf4j.Logger</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.slf4j.LoggerFactory</span><span class="o">;</span>

<span class="c1">// 声明 logger</span>
<span class="nc">Logger</span> <span class="n">log</span> <span class="o">=</span> <span class="nc">LoggerFactory</span><span class="o">.</span><span class="na">getLogger</span><span class="o">(</span><span class="nc">MainActivity</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>

<span class="c1">// 打印日志</span>
<span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"hello world"</span><span class="o">);</span>
<span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"number {}, boolean {}, string {}, object {}"</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="kc">true</span><span class="o">,</span> <span class="s">"string"</span><span class="o">,</span> <span class="k">new</span> <span class="nc">Object</span><span class="o">());</span>
</code></pre></div></div>

<p>运行 APP，可以看到日志输出到 logcat 和对应位置的文件。</p>

<p>当对配置有疑问，需要调试时，可以将上面配置文件里的 <code class="language-plaintext highlighter-rouge">debug="false"</code> 改为 <code class="language-plaintext highlighter-rouge">debug="true"</code>，这样 logback 就会输出详细的信息，方便我们定位问题。</p>

<h2 id="使用-lombok-注解生成日志对象">使用 Lombok 注解生成日志对象</h2>

<p>在上一部分的第 3 步，在每一个需要使用 logger 的类里，都需要手动去声明 logger，如 <code class="language-plaintext highlighter-rouge">Logger log = LoggerFactory.getLogger(MainActivity.class);</code>，不算方便。</p>

<p>这里我们可以使用 Lombok 注解来简化这一步骤，自动生成 logger 对象。</p>

<p>Lombok 官方提供了 Android 平台的集成说明：<a href="https://projectlombok.org/setup/android">https://projectlombok.org/setup/android</a></p>

<p>基于 Android Studio 环境，要做的其实就两步。</p>

<p>一、安装 Lombok 插件；</p>

<p><code class="language-plaintext highlighter-rouge">Settings -&gt; Plugins -&gt; 搜索 Lombok -&gt; 安装</code></p>

<p><em>注：Android Studio 版本 2020.3.1 - 2022.3.1，JetBrains 官方插件市场无法搜索到兼容版本的 Lombok 插件，可以参考 <a href="https://gitee.com/sgpublic/lombok-plugin-repository">https://gitee.com/sgpublic/lombok-plugin-repository</a> 解决。</em></p>

<p>二、在需要使用的模块的 build.gradle 文件里添加如下内容：</p>

<div class="language-groovy highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">dependencies</span> <span class="o">{</span>
	<span class="n">compileOnly</span> <span class="s1">'org.projectlombok:lombok:1.18.30'</span>
	<span class="n">annotationProcessor</span> <span class="s1">'org.projectlombok:lombok:1.18.30'</span>
<span class="o">}</span>
</code></pre></div></div>

<p>然后，就可以使用 <code class="language-plaintext highlighter-rouge">@Slf4j</code> 注解来自动生成 logger 对象了，现在的使用姿势简化成了这样：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Slf4j</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">test</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"hello world"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="小结">小结</h2>

<p>好了以上就是在 Android 里集成 slf4j + logback 的记录了，至此我「统一」了 Java 后端和 Android 客户端打印日志的用法，在避免多项目维护造成「精神分裂」的路上前进了一小步。</p>

<p>本文所列代码示例已上传至 GitHub，地址：<a href="https://github.com/mzlogin/AndroidPractices/tree/master/android-studio/LogbackDemo">https://github.com/mzlogin/AndroidPractices/tree/master/android-studio/LogbackDemo</a></p>

<p>以上步骤供有类似需求的同学参考，同时强烈建议以官方文档为主。如果有更好的方案，欢迎留言讨论交流。</p>

<h2 id="相关链接">相关链接</h2>

<ul>
  <li><a href="https://github.com/tony19/logback-android">https://github.com/tony19/logback-android</a></li>
  <li><a href="https://projectlombok.org/setup/android">https://projectlombok.org/setup/android</a></li>
  <li><a href="https://gitee.com/sgpublic/lombok-plugin-repository">https://gitee.com/sgpublic/lombok-plugin-repository</a></li>
  <li><a href="https://github.com/mzlogin/AndroidPractices/tree/master/android-studio/LogbackDemo">https://github.com/mzlogin/AndroidPractices/tree/master/android-studio/LogbackDemo</a></li>
</ul>]]></content><author><name>清风拂33</name></author><category term="Android" /><summary type="html"><![CDATA[Android APP 集成 slf4j + logback 作为日志框架，并使用 Lombok 注解生成日志对象。]]></summary></entry><entry><title type="html">Android｜FileProvider 的 authorities 重名会怎么样？</title><link href="http://localhost:4000/2023/10/19/when-provider-authorities-duplicated/" rel="alternate" type="text/html" title="Android｜FileProvider 的 authorities 重名会怎么样？" /><published>2023-10-19T00:00:00+08:00</published><updated>2023-10-19T00:00:00+08:00</updated><id>http://localhost:4000/2023/10/19/when-provider-authorities-duplicated</id><content type="html" xml:base="http://localhost:4000/2023/10/19/when-provider-authorities-duplicated/"><![CDATA[<p>先说结论：如果有两个或多个 FileProvider 的 authorities 重名，那么只有合并后的 AndroidManifest.xml 文件里，排在最前面的那个配置会生效。</p>

<h2 id="场景">场景</h2>

<p>应用里有个自升级的功能，下载完 apk 后，通过 FileProvider 提供 Uri 进行安装。我修改了文件下载路径后，功能失效了，报错如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>java.lang.IllegalArgumentException: Failed to find configured root that contains /data/user/0/org.mazhuang.test/cache/download/xxx.apk
    at android.support.v4.content.FileProvider$SimplePathStrategy.getUriForFile(FileProvider.java:738)
    at android.support.v4.content.FileProvider.getUriForFile(FileProvider.java:417)
</code></pre></div></div>

<p>对应的 provider 的声明是：</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;provider</span>
    <span class="na">android:name=</span><span class="s">"android.support.v4.content.FileProvider"</span>
    <span class="na">android:authorities=</span><span class="s">"${applicationId}.provider"</span>
    <span class="na">android:exported=</span><span class="s">"false"</span>
    <span class="na">android:grantUriPermissions=</span><span class="s">"true"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;meta-data</span>
        <span class="na">android:name=</span><span class="s">"android.support.FILE_PROVIDER_PATHS"</span>
        <span class="na">android:resource=</span><span class="s">"@xml/provider_paths"</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;/provider&gt;</span>
</code></pre></div></div>

<p>provider_paths 内容：</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span>
<span class="nt">&lt;paths</span> <span class="nt">&gt;</span>
    <span class="nt">&lt;cache-path</span> <span class="na">name=</span><span class="s">"internal_cache_download"</span> <span class="na">path=</span><span class="s">"download/"</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;/paths&gt;</span>
</code></pre></div></div>

<h2 id="分析">分析</h2>

<p>对照 FileProvider 官方文档：https://developer.android.com/reference/android/support/v4/content/FileProvider.html ，我再三确认了配置本身没有问题。</p>

<p>然后在报错堆栈的 <code class="language-plaintext highlighter-rouge">android.support.v4.content.FileProvider$SimplePathStrategy.getUriForFile</code> 方法处下断点调试：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Override</span>
<span class="kd">public</span> <span class="nc">Uri</span> <span class="nf">getUriForFile</span><span class="o">(</span><span class="nc">File</span> <span class="n">file</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// some code here</span>
    <span class="c1">// Find the most-specific root path</span>
    <span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">File</span><span class="o">&gt;</span> <span class="n">mostSpecific</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="nc">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">File</span><span class="o">&gt;</span> <span class="n">root</span> <span class="o">:</span> <span class="n">mRoots</span><span class="o">.</span><span class="na">entrySet</span><span class="o">())</span> <span class="o">{</span>
        <span class="kd">final</span> <span class="nc">String</span> <span class="n">rootPath</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="na">getValue</span><span class="o">().</span><span class="na">getPath</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">path</span><span class="o">.</span><span class="na">startsWith</span><span class="o">(</span><span class="n">rootPath</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">mostSpecific</span> <span class="o">==</span> <span class="kc">null</span>
                <span class="o">||</span> <span class="n">rootPath</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&gt;</span> <span class="n">mostSpecific</span><span class="o">.</span><span class="na">getValue</span><span class="o">().</span><span class="na">getPath</span><span class="o">().</span><span class="na">length</span><span class="o">()))</span> <span class="o">{</span>
            <span class="n">mostSpecific</span> <span class="o">=</span> <span class="n">root</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">mostSpecific</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">(</span>
                <span class="s">"Failed to find configured root that contains "</span> <span class="o">+</span> <span class="n">path</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="c1">// some code here</span>
<span class="o">}</span>
</code></pre></div></div>

<p>发现 SimplePathStrategy 的 mRoots 里确实没有我配置的路径。而 SimplePathStrategy 唯一的构造方法的参数是 authority，该实例的 authority 确实是 <code class="language-plaintext highlighter-rouge">${applicationId}.provider</code> 无误……那么，合理猜测，是有同名的 FileProvider，这里用到的是另一个 FileProvider 的 mRoots。</p>

<p>为了验证该猜测，我从两方面做确认：</p>

<ol>
  <li>
    <p>查看合并后的 AndroidManifest.xml 文件，是否有其它 FileProvider 的 authorities 也是 <code class="language-plaintext highlighter-rouge">${applicationId}.provider</code>？</p>
  </li>
  <li>
    <p>阅读 Android Frameworks 里的相关源码，确认解析 provider 配置、取 FileProvider 实例的逻辑。</p>
  </li>
</ol>

<h3 id="查看合并后的-androidmanifestxml">查看合并后的 AndroidManifest.xml</h3>

<p>现在 Android Studio 已经提供了非常方便的查看合并后的 AndroidManifest.xml 的功能，打开 app 项目的 AndroidMenifest.xml 文件，在编辑器底部有个 Merged Manifest 选项卡，点击即可查看。</p>

<p><img src="/images/posts/android/merged-manifest.png" alt="merged-manifest" /></p>

<p>可以看到，确实有两个 FileProvider 的 authorities 都是 <code class="language-plaintext highlighter-rouge">${applicationId}.provider</code>，另一个是从一个第三方库里来的，并且，它排在前面。</p>

<h3 id="源码确认">源码确认</h3>

<p>首先是在 Android Studio 里进行，找到调用 SimplePathStrategy 构造方法的地方，是在 <code class="language-plaintext highlighter-rouge">android.support.v4.content.FileProvider#parsePathStrategy</code>：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * Parse and return {@link PathStrategy} for given authority as defined in
 * {@link #META_DATA_FILE_PROVIDER_PATHS} {@code &lt;meta-data&gt;}.
 *
 * @see #getPathStrategy(Context, String)
 */</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="nc">PathStrategy</span> <span class="nf">parsePathStrategy</span><span class="o">(</span><span class="nc">Context</span> <span class="n">context</span><span class="o">,</span> <span class="nc">String</span> <span class="n">authority</span><span class="o">)</span>
        <span class="kd">throws</span> <span class="nc">IOException</span><span class="o">,</span> <span class="nc">XmlPullParserException</span> <span class="o">{</span>
    <span class="kd">final</span> <span class="nc">SimplePathStrategy</span> <span class="n">strat</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">SimplePathStrategy</span><span class="o">(</span><span class="n">authority</span><span class="o">);</span>

    <span class="kd">final</span> <span class="nc">ProviderInfo</span> <span class="n">info</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="na">getPackageManager</span><span class="o">()</span>
            <span class="o">.</span><span class="na">resolveContentProvider</span><span class="o">(</span><span class="n">authority</span><span class="o">,</span> <span class="nc">PackageManager</span><span class="o">.</span><span class="na">GET_META_DATA</span><span class="o">);</span>
    <span class="c1">// some code here</span>
<span class="o">}</span>
</code></pre></div></div>

<p>这里的 <code class="language-plaintext highlighter-rouge">context.getPackageManager().resolveContentProvider</code> 的实现，一路通过以下路径找到：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// android.app.ContextImpl#getPackageManager</span>
<span class="c1">// --&gt;</span>
<span class="c1">// android.app.ActivityThread#getPackageManager</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="nc">IPackageManager</span> <span class="nf">getPackageManager</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">sPackageManager</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">sPackageManager</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="nc">IBinder</span> <span class="n">b</span> <span class="o">=</span> <span class="nc">ServiceManager</span><span class="o">.</span><span class="na">getService</span><span class="o">(</span><span class="s">"package"</span><span class="o">);</span>
    <span class="n">sPackageManager</span> <span class="o">=</span> <span class="nc">IPackageManager</span><span class="o">.</span><span class="na">Stub</span><span class="o">.</span><span class="na">asInterface</span><span class="o">(</span><span class="n">b</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">sPackageManager</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>到这里动用一点历史经验，可知实际实现类是 PackageManagerService，来看看 <code class="language-plaintext highlighter-rouge">PackageManagerService#resolveContentProvider</code> 的实现：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Override</span>
<span class="kd">public</span> <span class="nc">ProviderInfo</span> <span class="nf">resolveContentProvider</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="o">,</span> <span class="kt">int</span> <span class="n">userId</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(!</span><span class="n">sUserManager</span><span class="o">.</span><span class="na">exists</span><span class="o">(</span><span class="n">userId</span><span class="o">))</span> <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="n">flags</span> <span class="o">=</span> <span class="n">updateFlagsForComponent</span><span class="o">(</span><span class="n">flags</span><span class="o">,</span> <span class="n">userId</span><span class="o">,</span> <span class="n">name</span><span class="o">);</span>
    <span class="kd">final</span> <span class="nc">String</span> <span class="n">instantAppPkgName</span> <span class="o">=</span> <span class="n">getInstantAppPackageName</span><span class="o">(</span><span class="nc">Binder</span><span class="o">.</span><span class="na">getCallingUid</span><span class="o">());</span>
    <span class="c1">// reader</span>
    <span class="kd">synchronized</span> <span class="o">(</span><span class="n">mPackages</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">final</span> <span class="nc">PackageParser</span><span class="o">.</span><span class="na">Provider</span> <span class="n">provider</span> <span class="o">=</span> <span class="n">mProvidersByAuthority</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
        <span class="c1">// some code here</span>
    <span class="o">}</span>
    <span class="c1">// some code here</span>
<span class="o">}</span>
</code></pre></div></div>

<p>在 PackageManagerService 里继续查找写入 <code class="language-plaintext highlighter-rouge">mProvidersByAuthority</code> 的地方，在 <code class="language-plaintext highlighter-rouge">PackageManagerService#commitPackageSettings</code>：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * Adds a scanned package to the system. When this method is finished, the package will
 * be available for query, resolution, etc...
 */</span>
<span class="kd">private</span> <span class="kt">void</span> <span class="nf">commitPackageSettings</span><span class="o">(</span><span class="nc">PackageParser</span><span class="o">.</span><span class="na">Package</span> <span class="n">pkg</span><span class="o">,</span> <span class="nc">PackageSetting</span> <span class="n">pkgSetting</span><span class="o">,</span>
        <span class="nc">UserHandle</span> <span class="n">user</span><span class="o">,</span> <span class="kt">int</span> <span class="n">scanFlags</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">chatty</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">PackageManagerException</span> <span class="o">{</span>
    <span class="c1">// some code here</span>
    <span class="kd">synchronized</span> <span class="o">(</span><span class="n">mPackages</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// some code here</span>
        <span class="k">for</span> <span class="o">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="nc">PackageParser</span><span class="o">.</span><span class="na">Provider</span> <span class="n">p</span> <span class="o">=</span> <span class="n">pkg</span><span class="o">.</span><span class="na">providers</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
            <span class="n">p</span><span class="o">.</span><span class="na">info</span><span class="o">.</span><span class="na">processName</span> <span class="o">=</span> <span class="n">fixProcessName</span><span class="o">(</span><span class="n">pkg</span><span class="o">.</span><span class="na">applicationInfo</span><span class="o">.</span><span class="na">processName</span><span class="o">,</span>
                    <span class="n">p</span><span class="o">.</span><span class="na">info</span><span class="o">.</span><span class="na">processName</span><span class="o">);</span>
            <span class="n">mProviders</span><span class="o">.</span><span class="na">addProvider</span><span class="o">(</span><span class="n">p</span><span class="o">);</span>
            <span class="n">p</span><span class="o">.</span><span class="na">syncable</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">info</span><span class="o">.</span><span class="na">isSyncable</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">info</span><span class="o">.</span><span class="na">authority</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="nc">String</span> <span class="n">names</span><span class="o">[]</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">info</span><span class="o">.</span><span class="na">authority</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="s">";"</span><span class="o">);</span>
                <span class="n">p</span><span class="o">.</span><span class="na">info</span><span class="o">.</span><span class="na">authority</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
                <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">names</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                    <span class="c1">// some code here</span>
                    <span class="c1">// 【我们要找的地方】</span>
                    <span class="k">if</span> <span class="o">(!</span><span class="n">mProvidersByAuthority</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">names</span><span class="o">[</span><span class="n">j</span><span class="o">]))</span> <span class="o">{</span>
                        <span class="n">mProvidersByAuthority</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">names</span><span class="o">[</span><span class="n">j</span><span class="o">],</span> <span class="n">p</span><span class="o">);</span>
                        <span class="k">if</span> <span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">info</span><span class="o">.</span><span class="na">authority</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                            <span class="n">p</span><span class="o">.</span><span class="na">info</span><span class="o">.</span><span class="na">authority</span> <span class="o">=</span> <span class="n">names</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
                        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                            <span class="n">p</span><span class="o">.</span><span class="na">info</span><span class="o">.</span><span class="na">authority</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">info</span><span class="o">.</span><span class="na">authority</span> <span class="o">+</span> <span class="s">";"</span> <span class="o">+</span> <span class="n">names</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
                        <span class="o">}</span>
                        <span class="c1">// some code here</span>
</code></pre></div></div>

<p>从上面这段中我们可以得到两个知识点：</p>

<ol>
  <li>
    <p>如果已经有同名的 authority，那么后面的 Provider 配置会被忽略掉；</p>
  </li>
  <li>
    <p>authority 可以配置多个，用分号分隔。（这一点在官方文档之类的都没有找到说明，也许官方觉得配置项的名称 <code class="language-plaintext highlighter-rouge">autorities</code> 就说明了一切？实测可正常使用。）</p>
  </li>
</ol>

<p>接下来还有一点需要确认的，就是 <code class="language-plaintext highlighter-rouge">pkg.providers</code> 是否是按 AndroidManifexs.xml 里的顺序排列的。</p>

<p>根据上面代码里的线索，可以留意到 <code class="language-plaintext highlighter-rouge">PackageParser</code> 类，按如下顺序递进：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// android.content.pm.PackageParser#parseBaseApk(java.io.File, android.content.res.AssetManager, int)</span>
<span class="kd">private</span> <span class="nc">Package</span> <span class="nf">parseBaseApk</span><span class="o">(</span><span class="nc">File</span> <span class="n">apkFile</span><span class="o">,</span> <span class="nc">AssetManager</span> <span class="n">assets</span><span class="o">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="o">)</span>
        <span class="kd">throws</span> <span class="nc">PackageParserException</span> <span class="o">{</span>
        <span class="c1">// some code here</span>
        <span class="c1">// 下面这行里的 ANDROID_MANIFEST_FILENAME = AndroidManifest.xml</span>
        <span class="n">parser</span> <span class="o">=</span> <span class="n">assets</span><span class="o">.</span><span class="na">openXmlResourceParser</span><span class="o">(</span><span class="n">cookie</span><span class="o">,</span> <span class="no">ANDROID_MANIFEST_FILENAME</span><span class="o">);</span>

        <span class="kd">final</span> <span class="nc">String</span><span class="o">[]</span> <span class="n">outError</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>
        <span class="kd">final</span> <span class="nc">Package</span> <span class="n">pkg</span> <span class="o">=</span> <span class="n">parseBaseApk</span><span class="o">(</span><span class="n">apkPath</span><span class="o">,</span> <span class="n">res</span><span class="o">,</span> <span class="n">parser</span><span class="o">,</span> <span class="n">flags</span><span class="o">,</span> <span class="n">outError</span><span class="o">);</span>
        <span class="c1">// some code here</span>
<span class="o">}</span>

<span class="c1">// --&gt; </span>
<span class="c1">// android.content.pm.PackageParser#parseBaseApk(java.lang.String, android.content.res.Resources, android.content.res.XmlResourceParser, int, java.lang.String[])</span>
<span class="c1">// --&gt;</span>
<span class="c1">// android.content.pm.PackageParser#parseBaseApkCommon</span>
<span class="c1">// --&gt;</span>
<span class="c1">// android.content.pm.PackageParser#parseBaseApplication</span>
<span class="c1">// --&gt;</span>
<span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">parseBaseApplication</span><span class="o">(</span><span class="nc">Package</span> <span class="n">owner</span><span class="o">,</span> <span class="nc">Resources</span> <span class="n">res</span><span class="o">,</span>
        <span class="nc">XmlResourceParser</span> <span class="n">parser</span><span class="o">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="o">,</span> <span class="nc">String</span><span class="o">[]</span> <span class="n">outError</span><span class="o">)</span>
    <span class="c1">// some code here</span>
    <span class="k">while</span> <span class="o">((</span><span class="n">type</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="na">next</span><span class="o">())</span> <span class="o">!=</span> <span class="nc">XmlPullParser</span><span class="o">.</span><span class="na">END_DOCUMENT</span>
            <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">type</span> <span class="o">!=</span> <span class="nc">XmlPullParser</span><span class="o">.</span><span class="na">END_TAG</span> <span class="o">||</span> <span class="n">parser</span><span class="o">.</span><span class="na">getDepth</span><span class="o">()</span> <span class="o">&gt;</span> <span class="n">innerDepth</span><span class="o">))</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">type</span> <span class="o">==</span> <span class="nc">XmlPullParser</span><span class="o">.</span><span class="na">END_TAG</span> <span class="o">||</span> <span class="n">type</span> <span class="o">==</span> <span class="nc">XmlPullParser</span><span class="o">.</span><span class="na">TEXT</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">continue</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="nc">String</span> <span class="n">tagName</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="na">getName</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">tagName</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">"activity"</span><span class="o">))</span> <span class="o">{</span>
            <span class="c1">// some code here</span>
        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">tagName</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">"provider"</span><span class="o">))</span> <span class="o">{</span>
            <span class="nc">Provider</span> <span class="n">p</span> <span class="o">=</span> <span class="n">parseProvider</span><span class="o">(</span><span class="n">owner</span><span class="o">,</span> <span class="n">res</span><span class="o">,</span> <span class="n">parser</span><span class="o">,</span> <span class="n">flags</span><span class="o">,</span> <span class="n">outError</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">p</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">mParseError</span> <span class="o">=</span> <span class="nc">PackageManager</span><span class="o">.</span><span class="na">INSTALL_PARSE_FAILED_MANIFEST_MALFORMED</span><span class="o">;</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="n">owner</span><span class="o">.</span><span class="na">providers</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">p</span><span class="o">);</span>
        <span class="c1">// some code here</span>
</code></pre></div></div>

<p>至此，我们已经可以确定 <code class="language-plaintext highlighter-rouge">pkg.providers</code> 是按 AndroidManifest.xml 里的顺序解析出来的了。</p>

<h2 id="解决方案">解决方案</h2>

<p>既然已经知道了问题的原因，那么解决方案也就呼之欲出了：</p>

<ul>
  <li>修改自己的 FileProvider 的 authorities，不会和其它库的 authorities 重名即可。</li>
</ul>

<h2 id="小结">小结</h2>

<blockquote>
  <p>源码面前，了无秘密。——侯捷</p>
</blockquote>

<p>如果遇到疑难问题，而恰好又有源码可查，那么就不要犹豫，直接去看源码吧！花一些时间和耐心，最终会找到你想要的。</p>]]></content><author><name>清风拂33</name></author><category term="Android" /><summary type="html"><![CDATA[Android 的 FileProvider 的 authorities 重名会怎么样？]]></summary></entry><entry><title type="html">代码审查｜这段代码，为什么复制文件夹总是“成功”？</title><link href="http://localhost:4000/2023/10/18/why-always-results-true/" rel="alternate" type="text/html" title="代码审查｜这段代码，为什么复制文件夹总是“成功”？" /><published>2023-10-18T00:00:00+08:00</published><updated>2023-10-18T00:00:00+08:00</updated><id>http://localhost:4000/2023/10/18/why-always-results-true</id><content type="html" xml:base="http://localhost:4000/2023/10/18/why-always-results-true/"><![CDATA[<p>最近开始一个人负责整个项目的全栈开发和维护，工作中没了和同事交叉 code review 的环节，所以就打算，如果工作中遇到一些比较典型的代码，包括好味道和坏味道，就拿出来分析下，与大家一起交流，作为另一种形式的「交叉 review」。</p>

<p>这天遇到这样一个问题：在 Android 手机上复制 assets 里的文件夹到手机里，实际并没有拷贝完成，但代码总是显示成功，看了下代码，使用的是阿里云播放器 Android SDK 的 Demo 里的一个工具类。</p>

<p>工具类里的相关代码经过简化后示意如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Commen</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="nc">Commen</span> <span class="n">instance</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">volatile</span> <span class="kt">boolean</span> <span class="n">isSuccess</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">Commen</span> <span class="nf">getInstance</span><span class="o">(</span><span class="nc">Context</span> <span class="n">context</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// some code here，单例控制，返回 instance</span>
        <span class="c1">// ...</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">copyAssetsToDst</span><span class="o">(</span><span class="nc">Context</span> <span class="n">context</span><span class="o">,</span> <span class="nc">String</span> <span class="n">srcPath</span><span class="o">,</span> <span class="nc">String</span> <span class="n">dstPath</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="nc">String</span><span class="o">[]</span> <span class="n">fileNames</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="na">getAssets</span><span class="o">().</span><span class="na">list</span><span class="o">(</span><span class="n">srcPath</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">fileNames</span><span class="o">.</span><span class="na">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">fileName</span> <span class="o">:</span> <span class="n">fileNames</span><span class="o">)</span> <span class="o">{</span>
                    <span class="c1">// 文件夹，递归调用</span>
                    <span class="n">copyAssetsToDst</span><span class="o">(</span><span class="n">context</span><span class="o">,</span> <span class="n">srcPath</span> <span class="o">+</span> <span class="nc">File</span><span class="o">.</span><span class="na">separator</span> <span class="o">+</span> <span class="n">fileName</span><span class="o">,</span>
                            <span class="n">dstPath</span> <span class="o">+</span> <span class="nc">File</span><span class="o">.</span><span class="na">separator</span> <span class="o">+</span> <span class="n">fileName</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// some code here，单个文件拷贝</span>
                <span class="c1">// ...</span>
            <span class="o">}</span>
            <span class="n">isSuccess</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">isSuccess</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>这段代码使用起来若不谨慎，至少存在以下问题：</p>

<ol>
  <li>
    <p>线程安全问题：该类是一个单例类，代码中的 <code class="language-plaintext highlighter-rouge">isSuccess</code> 相当于是一个全局变量，如果多个线程同时调用 <code class="language-plaintext highlighter-rouge">copyAssetsToDst</code> 方法，会出现线程安全问题，导致 <code class="language-plaintext highlighter-rouge">isSuccess</code> 的值被交叉覆盖，不可预期；</p>
  </li>
  <li>
    <p>结果正确性：因为 Exception 全都被 catch 住了，这样如果 srcPath 是一个文件夹，递归调用方法自身后，最外层总是会将 <code class="language-plaintext highlighter-rouge">isSuccess</code> 设置为 true，导致最终结果总是显示成功，而实际结果未知。</p>
  </li>
</ol>

<p>如果由我来写这段代码，我会做这样的修改：</p>

<ul>
  <li>
    <p>将类改为工具类，公开的方法都是静态方法，不需要单例控制；</p>
  </li>
  <li>
    <p>方法执行是否成功，由返回值、是否抛出异常来表示，不使用成员变量记录；</p>
  </li>
  <li>
    <p>拷贝过程中，记录拷贝成功的文件列表，如果最终失败，将中间生成的文件做清理。</p>
  </li>
</ul>]]></content><author><name>清风拂33</name></author><category term="Java" /><summary type="html"><![CDATA[遇到一个 Bug，复制文件夹总是“成功”，实际结果并非如此，对应的代码比较典型，拿出来分析下。]]></summary></entry></feed>